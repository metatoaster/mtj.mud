Exits
=====
- Two types
- One that will be like a double link list
- The other will be a one way
- Two way will be like this:

- Standard two way exit?
Exit2
  exit = [room1, room2] (invariant len(Exit2) == 2)
  exit.enter(person, person.room(?)) (other params generalized?)
    # enter the other room

  both rooms will contain the relevant exits
  room1.exits = {'south': exit, ...}
  room2.exits = {'north': exit, ...}

- One way exit
Exit1
  exit = room
  exit.enter(person, person.room)


Event queue
===========

This like reader/writer problem
- each soul act as a reader (multiple readers)
- the event processor is the writer
- FIXME - need to demonstrate that this queue works by moving the say command
to use this queue.


World
=====
- If there's a list that will keep track of all objects that exist in
the world, it can help with deleting unwanted objects (like logging out
people).


Commands
========
- Distinctions between a method that is a command (send) and the one that
receives information or output (sendtouser) to the object.  Formatting too?
- Instead of doing stuff in process_cmd, make a do_cmd that actually
  does the command.  Make process_cmd to find the object to action the cmd
  in


Get Command
===========
Wizards can get anything, players can only pick up a subset of MudObjects
- Check object based on inheritance, perhaps.


Rooms
=====
A room factory will be nice to generate a bunch of rooms that have more
or less same descriptions.
